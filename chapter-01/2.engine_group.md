# Engine Group

通过Engine Group，配合不通的策略，可以达到读写分离，负载均衡的效果。例如：

```Go
import (
    _ "github.com/lib/pq"
    "github.com/xormplus/xorm"
)

var eg *xorm.EngineGroup

func main() {
	conns := []string{
		"postgres://postgres:root@localhost:5432/test?sslmode=disable;",
		"postgres://postgres:root@localhost:5432/test1?sslmode=disable;",
		"postgres://postgres:root@localhost:5432/test2?sslmode=disable",
	}
    
    var err error
	eg, err = xorm.NewEngineGroup("postgres", conns)
    
    if err != nil {
		return
	}
    
    user := new(User)
	user.Name = "myname"
	affected, err := eg.Insert(user)
	// INSERT INTO user (name) values (?)
    if err != nil {
		return
	}
}
```

EngineGroup对数据库的SQL操作方法集和Engine是完全一致的，上例中是对数据库进行Insert操作，写操作和数据库事务操作都将在Master数据库中执行。而读操作则是依据负载策略在某个Slave中执行。

EngineGroup的Session
EngineGroup和Engine一样可以通过NewSession()方法来创建EngineGroup的Session，下例中，在同一个EngineGroup的Session中，执行写操作是在Master数据库中执行，执行读操作时则在Slave数据库执行。

xorm并不推荐在同一个EngineGroup的Session中同时进行读写操作，如需要，请使用事务，事务操作将全部在Master数据库中执行读写操作。

```Go
session := eg.NewSession()
defer session.Close()
    
user := new(User)
user.Name = "myname"
affected, err := session.Insert(user)
// INSERT INTO user (name) values (?)
if err != nil {
	return
}

_, err = session.Exec("delete from userinfo where username = ?", user2.Username)
if err != nil {
    return
}

sql := "select * from userinfo"
results, err := engine.Query(sql)
if err != nil {
    return
}

_, err = session.Exec("delete from userinfo where username = ?", user2.Username)
if err != nil {
    return
}
```